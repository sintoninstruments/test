<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ChargeBug: An EV Charging Forecast</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>

/* Friendly Consumer Theme for ChargeBug */

:root {
  --green: #CDE3C1;
  --green-dark: #609343;
  --yellow: #FFEB3B;
  --blue: #42A5F5;
  --gray-light: #F7F7F7;
  --gray-dark: #546E7A;
  --text-dark: #333333;
  --white: #FFFFFF;
  --radius: 14px;
  --shadow: 0 4px 12px rgba(0,0,0,0.08);
}

body {
  font-family: "Segoe UI", Arial, sans-serif;
  background: var(--gray-light);
  color: var(--text-dark);
  padding: 20px;
  line-height: 1.5;
}

/* Page Title */
h2 {
  text-align: center;
  font-size: 28px;
  margin-bottom: 20px;
  font-weight: 700;
  color: var(--green-dark);
}

/* Panels */
.panel {
  background: white;
  border-radius: var(--radius);
  padding: 18px;
  margin: 20px auto;
  max-width: 900px;
  box-shadow: var(--shadow);
}

/* Status + Green Window */
#statusBox,
#greenWindow,
#nextGreenHour {
  padding: 8px;
  border-radius: var(--radius);
  font-weight: 600;
  margin-bottom: 10px;
  box-shadow: var(--shadow);
}

#greenWindow:empty,
#nextGreenHour:empty {
  display: none;
}

/* Last Updated */
#lastUpdated {
  text-align: center;
  font-style: italic;
  margin-top: 10px;
  color: var(--gray-dark);
}

/* Table */
table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  border-radius: var(--radius);
  overflow: hidden;
  box-shadow: var(--shadow);
}

th {
  background: var(--green);
  color: white;
  padding: 10px;
  font-weight: 600;
}

td {
  padding: 10px;
  border-bottom: 1px solid #eee;
}

tr:nth-child(even) {
  background: #fafafa;
}



/* Calendar Container */
#calendarContainer {
  margin-top: 0px;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 10px;
}

/* Default: mobile behavior (scroll + left aligned) */
#calendarDayStrip,
#calendarNightStrip,
#calendarPlainStrip {
  display: flex;
  flex-wrap: nowrap;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;

  justify-content: flex-start;
  align-items: center;
  gap: 10px;

  min-width: max-content; /* ensures scroll instead of wrap */
}

/* Desktop: left align */
@media (min-width: 800px) {
  #calendarDayStrip,
  #calendarNightStrip,
  #calendarPlainStrip {
    justify-content: flex-start;   /* left aligned */
    overflow-x: visible;           /* no scrollbars */
  }
}

/* Header cells */
#calendarDayStrip h3,
#calendarNightStrip h3,
#calendarPlainStrip h3 {
  width: 60px;
  text-align: right;
  margin: 0;
  flex: 0 0 auto;
}

/* Calendar boxes */
.calendar-day,
.calendar-night,
.calendar-plain {
  width: 102px;
  height: 45px;
  border-radius: var(--radius);
  background: white;
  box-shadow: var(--shadow);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  font-size: 14px;
  text-align: center;
  flex: 0 0 auto;
}

/* Friendly colors */
.calendar-day {
  background: #FFFDE7;
}

.calendar-night {
  background: #E3F2FD;
}

.green-day {
  background: var(--yellow);
}

.green-night {
  background: var(--blue);
  color: white;
}

/* Buttons */
button {
  background: var(--green);
  color: white;
  border: none;
  padding: 12px 18px;
  border-radius: var(--radius);
  font-size: 16px;
  cursor: pointer;
  box-shadow: var(--shadow);
  transition: background 0.2s;
}

button:hover {
  background: var(--green-dark);
}

/* Mobile calendar box scaling */
@media (max-width: 600px) {
  .calendar-day,
  .calendar-night,
  .calendar-plain {
    width: 19vw;
    height: 10vw;
    font-size: 3vw;
  }
}

/* Table scroll on mobile */
@media (max-width: 600px) {
  table {
    display: block;
    overflow-x: auto;
    white-space: nowrap;
  }
}

/* Mobile padding */
@media (max-width: 600px) {
  body {
    padding: 10px;
  }
}

button {
  width: 100%;
}

/* Shared scroll wrapper for calendar + chart */
#scrollWrapper {
  width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  display: block;
}

/* Canvas must NOT shrink */
#evForecastChart {
  display: block;
  height: 300px;
  min-width: max-content; /* allow chart to grow wider than screen */
  width: auto;
}

  </style>

  <!-- Load Chart.js libraries -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>

<body>

  <div id="statusBox">Loading forecast status...</div>
  <div id="greenWindow"></div>
  <div id="nextGreenHour"></div>

<div id="scrollWrapper">
  <div id="calendarContainer">
    <div id="calendarPlainStrip"></div>
    <div id="calendarDayStrip"></div>
    <div id="calendarNightStrip"></div>
  </div>

  <canvas id="evForecastChart"></canvas>
</div>


  <div id="lastUpdated"></div>

  <button onclick="toggleTableVisibility()" style="margin-bottom: 12px;">
    Show/Hide Data Table
  </button>

  <table id="csvTable"></table>


  <script>
    // Disable right-click and copy/cut/inspect shortcuts
    document.addEventListener("contextmenu", e => e.preventDefault());
    document.addEventListener("copy", e => e.preventDefault());
    document.addEventListener("cut", e => e.preventDefault());
    document.addEventListener("keydown", e => {
      if ((e.ctrlKey || e.metaKey) && ["c", "x", "u", "s"].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
    });


// Convert a Date object to an ISO-like string in Mountain Time
function toMountainISO(date) {
  // Convert to Mountain Time using Intl
  const mt = new Date(
    date.toLocaleString("en-US", { timeZone: "America/Denver" })
  );

  const pad = n => String(n).padStart(2, "0");

  const year = mt.getFullYear();
  const month = pad(mt.getMonth() + 1);
  const day = pad(mt.getDate());
  const hour = pad(mt.getHours());
  const minute = pad(mt.getMinutes());
  const second = pad(mt.getSeconds());

  // ISO-like string, but in MT instead of UTC
  return `${year}-${month}-${day}T${hour}:${minute}:${second}`;
}


    function toggleTableVisibility() {
      const table = document.getElementById("csvTable");
      if (!table) return;
      const isHidden = table.style.display === "none";
      table.style.display = isHidden ? "table" : "none";
    }

    function subtractOneHour(timestamp) {
      // Expects "MM/DD/YYYY HH:MM:SS"
      const [datePart, timePart] = timestamp.split(" ");
      const [month, day, year] = datePart.split("/").map(Number);
      const [hour, minute, second] = timePart.split(":").map(Number);
      const originalDate = new Date(year, month - 1, day, hour, minute, second);
      originalDate.setHours(originalDate.getHours() - 1);
      return originalDate;
    }

async function importJSON() {
  const url = "https://weis-api.vercel.app/api/weis";

  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error("Status: " + response.status);

    const json = await response.json();

    // ⭐ Use the API timestamp instead of local refresh time
    const apiTime = new Date(json.updated).toLocaleString("en-US", {
      timeZone: "America/Denver"
    });

    document.getElementById("lastUpdated").textContent =
      `Last updated from SPP WEIS: ${apiTime}`;

    displayJSON(json.rows);

  } catch (error) {
    document.getElementById("lastUpdated").textContent =
      "Download failed. " + error;
  }
}

function displayJSON(rows) {
  const newHeaders = [
    "Interval",
    "MTLF",
    "MTSF",
    "MTWF",
    "MTSFx1.4",
    "MTLFCorrected",
    "Green Fraction",
    "Solar Fraction",
    "Wind Fraction",
    "Green",
    "Interval (MT)"
  ];

 let dataRows = [];

document.getElementById("csvTable").style.display = "none";

// Build dataRows
rows.forEach(row => {
  // ⭐ Normalize keys
  const cleanRow = {};
  Object.keys(row).forEach(k => {
    cleanRow[k.trim()] = row[k];
  });

  const mtlfVal = parseFloat(cleanRow["MTLF"]) || 0;
  const mtsfVal = parseFloat(cleanRow["MTSF"]) || 0;
  const mtwfVal = parseFloat(cleanRow["MTWF"]) || 0;

  if (!mtlfVal) return;

  const mtsf1_4 = mtsfVal * 1.4;
  const mtlfx = mtlfVal + mtsfVal * 0.4;
  const fraction = mtlfx !== 0 ? (mtsf1_4 + mtwfVal) / mtlfx : 0;
  const solarFraction = mtlfx !== 0 ? mtsf1_4 / mtlfx : 0;
  const windFraction = fraction - solarFraction;

  // Time conversion
  const rawInterval = cleanRow["Interval"];
  const [datePart, timePart] = rawInterval.split(" ");
  const [month, day, year] = datePart.split("/").map(Number);
  const [hour, minute, second] = timePart.split(":").map(Number);

  const mtDate = new Date(year, month - 1, day, hour, minute, second);
  mtDate.setHours(mtDate.getHours() - 1);

  const mtString = toMountainISO(mtDate);

  // Build row
  const rowData = [
    rawInterval,
    mtlfVal.toFixed(2),
    mtsfVal.toFixed(2),
    mtwfVal.toFixed(2),
    mtsf1_4.toFixed(2),
    mtlfx.toFixed(2),
    fraction.toFixed(2),
    solarFraction.toFixed(2),
    windFraction.toFixed(2),
    "0",
    mtString
  ];

  dataRows.push({ rowData, mtDate });
});

// ⭐ Keep only rows from today's midnight through +7 days
const midnight = new Date();
midnight.setHours(0, 0, 0, 0);

const sevenDaysLater = new Date(midnight.getTime() + 7 * 24 * 60 * 60 * 1000);

dataRows = dataRows.filter(d => 
  d.mtDate >= midnight && d.mtDate < sevenDaysLater
);

if (dataRows.length === 0) {
  return;
}


      dataRows.sort((a, b) => a.mtDate - b.mtDate);

      const fractionAvg =
        dataRows.reduce((sum, d) => sum + parseFloat(d.rowData[6]), 0) /
        dataRows.length;

      const now = new Date();
      now.setMinutes(0, 0, 0);
      const nowTime = now.getTime();
      let currentGreen = null;

      const intervals = [];

      const table = document.getElementById("csvTable");
      if (!table) return;
      table.innerHTML = "";

      const headerRow = table.insertRow();
      newHeaders.forEach(h => {
        const th = document.createElement("th");
        th.textContent = h;
        headerRow.appendChild(th);
      });

      dataRows.forEach(({ rowData, mtDate }) => {
        const fraction = parseFloat(rowData[6]);
        const threshold = Math.min(fractionAvg, 0.45);
        const green = fraction > threshold ? "1" : "0";
        rowData[9] = green;

        const tr = table.insertRow();
        const hour = mtDate.getHours();
        if (hour >= 21 || hour < 8) {
          tr.style.backgroundColor = "#eee";
        }

        rowData.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });

        mtDate.setMinutes(0, 0, 0);
        intervals.push({ time: mtDate.getTime(), date: new Date(mtDate), green });

        if (mtDate.getTime() === nowTime) currentGreen = green;
      });

      // Status box
      const statusBox = document.getElementById("statusBox");
      if (statusBox) {
	const styles = getComputedStyle(document.documentElement);

	const greenColor = styles.getPropertyValue("--green").trim();
	const redColor   = "#FF7979"; // you can define a --red if you want
	const grayColor  = styles.getPropertyValue("--gray-light").trim();

	statusBox.style.backgroundColor =
  	currentGreen === "1" ? greenColor :
  	currentGreen === "0" ? redColor   :
  	grayColor;


        statusBox.textContent =
          `Current grid status: ${
            currentGreen === "1" ? "Clean and GREEN!" :
            currentGreen === "0" ? "Carbon-Heavy"   :
            "Unknown"
          }`;
      }

      // Green window messaging
      const greenWindowDiv = document.getElementById("greenWindow");
      if (greenWindowDiv) {
        if (currentGreen === "1") {
          let duration = 0;
          for (let i = 0; i < intervals.length; i++) {
            if (intervals[i].time === nowTime) {
              for (let j = i; j < intervals.length && intervals[j].green === "1"; j++) {
                duration++;
              }
              break;
            }
          }
          greenWindowDiv.textContent =
            `Green for the next ${duration} hour${duration !== 1 ? "s" : ""}`;
          greenWindowDiv.style.backgroundColor = "#609343";
        } else if (currentGreen === "0") {
          let duration = 0;
          for (let i = 0; i < intervals.length; i++) {
            if (intervals[i].time === nowTime) {
              for (let j = i; j < intervals.length && intervals[j].green === "0"; j++) {
                duration++;
              }
              break;
            }
          }
          greenWindowDiv.textContent =
            `Grid will be green in ${duration} hour${duration !== 1 ? "s" : ""}`;
          greenWindowDiv.style.backgroundColor = "#F7F7F7";
        } else {
          greenWindowDiv.textContent = "Current green status unknown.";
          greenWindowDiv.style.backgroundColor = "#F7F7F7";
        }
      }

  function hoursToRanges(hours) {
  if (!hours || hours.length === 0) return "—";

  // Copy and sort to avoid mutating the original
  const sorted = [...hours].sort((a, b) => a - b);

  const ranges = [];
  let start = sorted[0];
  let prev = sorted[0];

  for (let i = 1; i < sorted.length; i++) {
    const h = sorted[i];
    if (h !== prev + 1) {
      ranges.push([start, prev]);
      start = h;
    }
    prev = h;
  }
  ranges.push([start, prev]);

  const fmt = h => {
    const hour = h % 12 === 0 ? 12 : h % 12;
    const suffix = h < 12 ? "A" : "P";
    return hour + suffix;
  };

  // end is inclusive hour; add 1 to make end time exclusive
  return ranges.map(([s, e]) => `${fmt(s)}–${fmt(e + 1)}`).join(", ");
}    

// Build day/night calendar
const calendarDayDiv = document.getElementById("calendarDayStrip");
const calendarNightDiv = document.getElementById("calendarNightStrip");
const calendarPlainDiv = document.getElementById("calendarPlainStrip");

// We'll track how many days we actually render
let renderedDayCount = 0;

if (calendarDayDiv && calendarNightDiv && calendarPlainDiv) {
  calendarDayDiv.innerHTML = "<h3 style='margin-bottom: 8px;padding-right:5px;'>Day</h3>";
  calendarNightDiv.innerHTML = "<h3 style='margin-bottom: 8px;padding-right:5px;'>Night</h3>";
  calendarPlainDiv.innerHTML = "<h3 style='margin-bottom: 8px;padding-right:5px;'>&nbsp;</h3>";

  const calendarMap = {}; // key: date string, value: { dayHours: [], nightHours: [] }

  intervals.forEach(i => {
    const date = i.date instanceof Date ? i.date : new Date(i.date);
    const hour = date.getHours();
    const key = date.toLocaleDateString("en-CA"); // YYYY-MM-DD

    if (!calendarMap[key]) {
      calendarMap[key] = { dayHours: [], nightHours: [] };
    }

    // Day: 8–21 (8:00–21:00)
    if (hour >= 8 && hour < 21 && i.green === "1") {
      calendarMap[key].dayHours.push(hour);
    }

    // Night hours belong to the "night" of that day (21–24 and 0–8 next day)
    if (hour >= 21 || hour < 8) {
      const nightKeyDate = new Date(date);
      if (hour < 8) nightKeyDate.setDate(nightKeyDate.getDate() - 1);
      const nightKey = nightKeyDate.toLocaleDateString("en-CA");

      if (!calendarMap[nightKey]) {
        calendarMap[nightKey] = { dayHours: [], nightHours: [] };
      }
      if (i.green === "1") {
        calendarMap[nightKey].nightHours.push(hour);
      }
    }
  });

  Object.keys(calendarMap)
    .sort()
    .slice(1, 8)
    .forEach(dateStr => {
      const entry = calendarMap[dateStr];
      const dayHours = entry?.dayHours || [];
      const nightHours = entry?.nightHours || [];

      const [year, month, day] = dateStr.split("-").map(Number);
      const localDate = new Date(year, month - 1, day);
      const dayName = localDate.toLocaleDateString(undefined, { weekday: "short" });

      // Plain label
      const plainDiv = document.createElement("div");
      plainDiv.className = "calendar-plain";
      plainDiv.textContent = dayName;
      calendarPlainDiv.appendChild(plainDiv);

      // Day calendar
      const dayDiv = document.createElement("div");
      dayDiv.className = "calendar-day";
      dayDiv.style.backgroundColor = dayHours.length >= 5 ? "#FFEB3B" : "#B0BEC5";
      dayDiv.innerHTML = hoursToRanges(dayHours);
      calendarDayDiv.appendChild(dayDiv);

      // Night calendar
      const nightDiv = document.createElement("div");
      nightDiv.className = "calendar-night";
      nightDiv.style.backgroundColor = nightHours.length >= 5 ? "#81D4FA" : "#B0BEC5";
      nightDiv.innerHTML = hoursToRanges(nightHours);
      calendarNightDiv.appendChild(nightDiv);

      renderedDayCount++;
    });
}

// ---- NEW: compute a deterministic "calendar width" and apply to chart ----

// These should match your CSS:
// .calendar-*- box width, gap between boxes, and header width
const isMobile = window.innerWidth < 600;

const BOX_WIDTH = isMobile ? window.innerWidth * 0.19 : 102;
const BOX_GAP   = isMobile ? 10 : 10; // same gap
const HEADER_WIDTH = isMobile ? 60 : 60;

// total width = header + N * (box + gap)
const calendarWidthPx =
  renderedDayCount > 0
    ? HEADER_WIDTH + renderedDayCount * (BOX_WIDTH + BOX_GAP)
    : 900; // fallback if something goes wrong

// Build stacked solar/wind chart with dynamic green fraction line
const chartCanvas = document.getElementById("evForecastChart");

// Apply width/height to the canvas so Chart.js uses this size
if (chartCanvas) {
  chartCanvas.style.width = calendarWidthPx + "px"; // layout width
  chartCanvas.width = calendarWidthPx;              // drawing width
  chartCanvas.height = 300;
}

if (chartCanvas && window.Chart) {
  const styles = getComputedStyle(document.documentElement);

  const yellow = styles.getPropertyValue("--yellow").trim() + "B3"; // 70% opacity
  const blue   = styles.getPropertyValue("--blue").trim() + "B3";

  const intervalLabels = [];
  const solarStack = [];
  const windStack = [];
  const fractionLine = [];
  const fractionColors = [];

  dataRows.forEach(d => {
    const label = d.rowData[d.rowData.length - 1];
    intervalLabels.push(label);

    const solarFraction = parseFloat(d.rowData[d.rowData.length - 4]);
    const windFraction  = parseFloat(d.rowData[d.rowData.length - 3]);
    const fraction      = parseFloat(d.rowData[d.rowData.length - 5]);

    const clamped = Math.max(0, Math.min(fraction, 1));
    const lightness = 5 + clamped * 55;
    const color = `hsl(120, 100%, ${lightness}%)`;

    solarStack.push(isNaN(solarFraction) ? 0 : solarFraction);
    windStack.push(isNaN(windFraction) ? 0 : windFraction);
    fractionLine.push(isNaN(fraction) ? 0 : fraction);
    fractionColors.push(color);
  });

 const ctx = chartCanvas.getContext("2d");

new Chart(ctx, {
  type: "bar",
  data: {
    labels: intervalLabels,
    datasets: [
      {
        label: "Solar Fraction",
        data: solarStack,
        backgroundColor: yellow,
        borderColor: yellow,
        borderWidth: 5,
        stack: "clean"
      },
      {
        label: "Wind Fraction",
        data: windStack,
        backgroundColor: blue,
        borderColor: blue,
        borderWidth: 5,
        stack: "clean"
      },
      {
        label: "Green Fraction",
        type: "line",
        order: 99,
        data: fractionLine,
        borderWidth: 5,
        pointRadius: 0,
        fill: false,
        tension: 0.3,
        borderColor: "hsl(120, 100%, 40%)",
        segment: {
          borderColor: ctx => {
            const i = ctx.p0DataIndex;
            return fractionColors[i] || "hsl(120, 100%, 40%)";
          }
        }
      }
    ]
  },

  options: {
    responsive: false,
    maintainAspectRatio: false,

    plugins: {
      legend: { position: "top" },

      tooltip: {
        mode: "index",
        intersect: false,
        callbacks: {
          title: function (tooltipItems) {
            const raw = tooltipItems[0].label;
            const [datePart, timePart] = raw.split("T");
            const [year, month, day] = datePart.split("-");
            const hour = parseInt(timePart.split(":")[0]);

            const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
            const monthLabel = monthNames[parseInt(month) - 1];
            const dayLabel = parseInt(day);

            const formattedHour =
              hour === 0 ? "12 AM" :
              hour < 12 ? `${hour} AM` :
              hour === 12 ? "12 PM" :
              `${hour - 12} PM`;

            return `${monthLabel} ${dayLabel}, ${formattedHour}`;
          },
          label: function (context) {
            const label = context.dataset.label || "";
            const value = context.raw;
            return `${label}: ${Math.round(value * 100)}%`;
          }
        }
      }
    },

    scales: {
      x: {
        stacked: true,
        title: { display: true, text: "Date", color: "#000000", 
font: {
    family: "Segoe UI, Arial, sans-serif",
    weight: "normal"   // removes bold
  }
},
        ticks: {
          color: "#000000",
          font: {
    family: "Segoe UI, Arial, sans-serif",
    weight: "normal"   // removes bold
  }
,
          callback: function (value, index) {
            if (index % 24 === 12) {
              const raw = this.chart.data.labels[index];
              const [year, month, day] = raw.split("T")[0].split("-");
              const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
              return `${monthNames[parseInt(month) - 1]} ${parseInt(day)}`;
            }
            return "";
          },
          autoSkip: false,
          maxRotation: 0,
          minRotation: 0
        },
        grid: { color: "rgba(255,255,255,0.15)" }
      },

      y: {
        stacked: true,
        min: 0,
        max: 1,
        title: { display: true, text: "Percent Clean", color: "#000000", font: {
    family: "Segoe UI, Arial, sans-serif",
    weight: "normal"   // removes bold
  }
 },
        ticks: {
          color: "#000000",
          font: {
    family: "Segoe UI, Arial, sans-serif",
    weight: "normal"   // removes bold
  }
,
          callback: value => Math.round(value * 100) + "%"
        },
        grid: { color: "rgba(255,255,255,0.15)" }
      }
    }
  },

  });
}
}

    // Run after page load
    window.addEventListener("load", importJSON);
  </script>
</body>
</html>
